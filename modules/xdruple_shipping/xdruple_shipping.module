<?php

/**
 * @keeps theme callback
 */

use Xtuple\Xdruple\Theme\PrintAddressInfoHandler;

/**
 * Implements hook_rescued_resources().
 */
function xdruple_shipping_rescued_resources() {
  return array(
    "FreightClass",
    "ShipVia",
    "Site",
  );
}

/**
 * Implements hook_cpanel_alter()
 */
function xdruple_shipping_cpanel_alter(&$form, &$form_state) {
  if (module_exists('commerce_pickup')) {
    $sites = entity_load('xtuple_site');

    $options = array();
    foreach ($sites as $key => $site) {
      $options[$key] = $site->description;
    }
    if (count($sites) > 1) {
      $form['xdruple_commerce_store_settings']['xdruple_shipping_allowed_pickup_sites'] = array(
        '#type' => 'checkboxes',
        '#options' => $options,
        '#title' => t('Allowed Pickup Sites'),
        '#description' => t('Limit the Sites customers are allowed to pickup from. If checked, a Customer can choose to pickup their order from this Site location.'),
        '#required' => TRUE,
        '#default_value' => variable_get('xdruple_shipping_allowed_pickup_sites', array()),
      );
    }
    else {
      drupal_set_message(t('Cannot find any Sites to set as allowed pickup locations.'), 'warning');
    }
  }
}

/**
 * Implements hook_field_storage_pre_insert().
 */
function xdruple_shipping_field_storage_pre_insert($entity_type, $entity, &$skip_fields) {
  // Wrap the update hook, which does everything we need.
  xdruple_shipping_field_storage_pre_update($entity_type, $entity, $skip_fields);
}

/**
 * Implements hook_field_storage_pre_update().
 */
function xdruple_shipping_field_storage_pre_update($entity_type, $entity, &$skip_fields) {
  // Check $entity_type and only act on ones we support.
  $entity_info = entity_get_info($entity_type);

  if (isset($entity_info['discovery-client']) && $entity_info['discovery-client'] === 'xtuple') {

    // Get all the fields attached to this entity.
    $bundle = $entity_type === 'commerce_product' ? 'product' : $entity_type;
    $instances = field_info_instances($entity_type, $bundle);
    foreach ($instances as $field_name => $instance) {
      if ($field_name !== 'xt_physical_weight' && $field_name !== 'xt_physical_dimension') {
        continue;
      }

      $field_info = field_info_field($field_name);

      // TODO: Currently, these fields are read only. It is a calculated field
      // that combines the product and package weights. Therefore, there is
      // nothing to do on insert and updates.

      // Add this field to $skip_fields.
      $skip_fields[$field_info['id']] = $field_info;
    }
  }
}

/**
 * Implements hook_field_storage_pre_load().
 *
 * Side loads weight from a xTuple entity's 'productWeight' and 'packageWeight'
 * property into the 'xt_physical_weight' field.
 */
function xdruple_shipping_field_storage_pre_load($entity_type, $entities, $age, &$skip_fields, $options) {
  // Check $entity_type and only act on ones we support.
  $entity_info = entity_get_info($entity_type);

  if (isset($entity_info['discovery-client']) && $entity_info['discovery-client'] === 'xtuple') {

    // Get all the fields attached to this entity.
    $bundle = $entity_type === 'commerce_product' ? 'product' : $entity_type;
    $instances = field_info_instances($entity_type, $bundle);
    $valid_weights = xdruple_shipping_physical_weight_units();
    $valid_dimensions = xdruple_shipping_physical_dimension_units();

    foreach ($instances as $field_name => $instance) {
      // Only act on weight and dimension fields.
      if ($field_name !== 'xt_physical_weight' && $field_name !== 'xt_physical_dimension') {
        continue;
      }

      $field_info = field_info_field($field_name);
      $type = $field_info['type'];

      $resource = $entity_info['resource'];
      $entity_properties = $entity_info['json-schema'][$resource]['properties'];

      // Check the entity for 'urls' property.
      if (isset($entity_properties['productWeight']) || isset($entity_properties['packageWeight'])) {
        foreach ($entities as $entity_id => $entity) {
          if ($type === 'physical_weight') {
            $weight = 0;
            if (isset($entity_properties['weightUnit']) &&
              property_exists($entity, 'weightUnit') &&
              !empty($entity->weightUnit)
            ) {
              // Convert unit to commerce_physical.
              $weightUnit = xdruple_shipping_map_physical_weight_units($entity->weightUnit, $valid_weights);
            }
            else {
              // Get default UOM.
              $weightUnit = $instances['widget']['settings']['default_unit'];
            }

            if (property_exists($entity, 'productWeight') && !empty($entity->productWeight)) {
              $weight = $weight + $entity->productWeight;
            }
            if (property_exists($entity, 'packageWeight') && !empty($entity->packageWeight)) {
              $weight = $weight + $entity->packageWeight;
            }

            if (!empty($weight)) {
              // Associate that field with this product entity.
              $entity->xt_physical_weight[LANGUAGE_NONE][0] = array(
                'weight' => $weight,
                'unit' => $weightUnit,
              );
            }
          }
          elseif ($type === 'physical_dimensions') {
            if (isset($entity_properties['dimensionUnit']) &&
              property_exists($entity, 'dimensionUnit') &&
              !empty($entity->dimensionUnit)
            ) {
              // Convert unit to commerce_physical.
              $dimensionUnit = xdruple_shipping_map_physical_dimension_units($entity->dimensionUnit, $valid_dimensions);
            }
            else {
              // Get default UOM.
              $dimensionUnit = $instances['widget']['settings']['default_unit'];
            }

            if (property_exists($entity, 'packLength') && !empty($entity->packLength)) {
              $length = $entity->packLength;
            }
            if (property_exists($entity, 'packWidth') && !empty($entity->packWidth)) {
              $width = $entity->packWidth;
            }
            if (property_exists($entity, 'packHeight') && !empty($entity->packHeight)) {
              $height = $entity->packHeight;
            }

            if (!empty($length) && !empty($width) && !empty($height)) {
              // Associate that field with this product entity.
              $entity->xt_physical_dimension[LANGUAGE_NONE][0] = array(
                'length' => $length,
                'width' => $width,
                'height' => $height,
                'unit' => $dimensionUnit,
              );
            }
          }
        }
      }

      // Add this field to $skip_fields.
      $skip_fields[$field_info['id']] = $field_info;
    }
  }
}

/**
 * Gets a list of physical modules valid weight units.
 *
 * @See: physical_weight_units()
 *
 * @return array
 *   An array of valid weight units of measurement.
 */
function xdruple_shipping_physical_weight_units() {
  // Use drupal_static because this gets calls a lot repeatedly.
  $valid_units = &drupal_static(__FUNCTION__);

  if (!isset($valid_units)) {
    $valid_units = array_keys(physical_weight_units());
  }

  return $valid_units;
}

/**
 * Gets a list of physical modules valid dimension units.
 *
 * @See: physical_dimension_units()
 *
 * @return array
 *   An array of valid dimension units of measurement.
 */
function xdruple_shipping_physical_dimension_units() {
  // Use drupal_static because this gets calls a lot repeatedly.
  $valid_units = &drupal_static(__FUNCTION__);

  if (!isset($valid_units)) {
    $valid_units = array_keys(physical_dimension_units());
  }

  return $valid_units;
}

/**
 * Converts an xTuple UOM to physical modules weight unit.
 *
 * @See: physical_weight_units()
 *
 * @param string $unit
 *   The type of weight unit whose name should be returned; by default this can
 *   be lb, oz, kg, or g.
 *
 * @param array  $valid_units
 *   An array of valid physical modules weight units.
 *
 * @return string or FALSE
 *   The valid unit of measurement or FALSE if not found.
 */
function xdruple_shipping_map_physical_weight_units($unit, $valid_units) {
  $unit = strtolower($unit);

  if (in_array($unit, $valid_units)) {
    return $unit;
  }
  else {
    drupal_set_message(t('Weight unit of measure not valid.'), 'warning', FALSE);

    return FALSE;
  }
}

/**
 * Converts an xTuple UOM to dimension modules dimension unit.
 *
 * @See: physical_dimension_units()
 *
 * @param string $unit
 *   The type of dimension unit whose name should be returned; by default this can
 *   be in, ft, mm, cm, or m.
 *
 * @param array  $valid_units
 *   An array of valid physical modules dimension units.
 *
 * @return string or FALSE
 *   The valid unit of measurement or FALSE if not found.
 */
function xdruple_shipping_map_physical_dimension_units($unit, $valid_units) {
  $unit = strtolower($unit);

  if (in_array($unit, $valid_units)) {
    return $unit;
  }
  else {
    drupal_set_message(t('Dimension unit of measure not valid.'), 'warning', FALSE);

    return FALSE;
  }
}

/**
 * Converts a Commerce Shipping Service to xTuple's Ship Via code-description.
 *
 * @See: xdruple_commerce_commerce_checkout_complete()
 * @See: _commerce_ups_service_list()
 *
 * @param $ship_label
 *    The commerce line_item_label; by default this can be:
 *    'UPS Ground',
 *    'UPS Next Day Air',
 *    'UPS 2nd Day Air',
 *    etc.
 *
 * @return string
 *   The matching xTuple's Ship Via code or pass through $ship_label if not found.
 */
function xdruple_shipping_map_ship_via($ship_label) {
  $entity_type = 'xtuple_shipvia';
  $ship_vias = entity_load($entity_type);

  foreach ($ship_vias as $code => $value) {
    // Remove and space, dashes, underscores.
    $stripped_label = str_replace(array(' ', '-', '_'), '', $ship_label);
    $stripped_description = str_replace(array(' ', '-', '_'), '', $value->description);

    // Compare the two and return the code-description if they match.
    if ($stripped_label === $stripped_description) {
      return $code . '-' . $value->description;
    }
  }

  // Else, just pass through the $ship_label when no match is found.
  return $ship_label;
}

/**
 * Implements hook_form_alter().
 */
function xdruple_shipping_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['xt_physical_weight'])) {
    // Make 'xt_physical_weight' read only. It's a calculated field and can not be editied.
    $form['xt_physical_weight'][LANGUAGE_NONE][0]['weight']['#attributes']['disabled'] = TRUE;
    $form['xt_physical_weight'][LANGUAGE_NONE][0]['unit']['#attributes']['disabled'] = TRUE;

    // Add description explaining this.
    $description = t("This field is calculated based on the 'productWeight' + 'packageWeight'. It cannot be changed. To change the weight, edit those fields instead.");
    $form['xt_physical_weight'][LANGUAGE_NONE][0]['weight']['#description'] = $description;
  }
}

/**
 * Implements hook_commerce_ups_ship_to_address_from_order_alter()
 *
 * @param $ship_to_address
 * @param $order_wrapper
 */
function xdruple_shipping_commerce_ups_ship_to_address_from_order_alter(&$ship_to_address, $order_wrapper) {
  try {
    /** @var \stdClass $customer_shipping */
    $customer_shipping = $order_wrapper->commerce_customer_shipping->value();
    $customer_shipping_proxy = new \Xtuple\Drupal7\Proxy\CustomerProfileProxy($customer_shipping);
    /** @var \Xtuple\Entity\Contact\Contact $contact */
    $contact = $customer_shipping_proxy->contact();
    $address = $contact->address();
    $ship_to_address['thoroughfare'] = $address->thoroughfare();
    $ship_to_address['premise'] = $address->premise();
    $ship_to_address['locality'] = $address->locality();
    $ship_to_address['administrative_area'] = $address->administrativeArea();
    $ship_to_address['postal_code'] = $address->postalCode();
    $ship_to_address['country'] = $address->country();
    $ship_to_address['first_name'] = $contact->name()->first();
    $ship_to_address['last_name'] = $contact->name()->last();
    if (user_is_anonymous() && $customer = $order_wrapper->mail->value()) {
      $shipping_address['organisation_name'] = $customer;
    }
    elseif ($customer = $order_wrapper->customer->value()) {
      $shipping_address['organisation_name'] = $customer->get('name');
    }
  } catch (\Exception $e) {
    drupal_set_message($e->getMessage(), 'error');
    watchdog('xdruple_commerce', theme('exception', array(
      'exception' => $e,
    )), array(), WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_commerce_ups_ship_from_address_alter().
 */
function xdruple_shipping_commerce_ups_ship_from_address_alter(&$ship_from_address, $order_wrapper) {
  // Necessary for country_get_list().
  require_once DRUPAL_ROOT . '/includes/locale.inc';

  /** @var Xtuple\Xdruple\Session\RescuedSession $session */
  $session = extensions_get_session();

  $id = $session->getRescued('site');
  $entity_type = 'xtuple_site';

  if (!empty($id)) {
    $site = entity_load_single($entity_type, $id);
  }
  else {
    // Default site from control panel to support anonymous checkout.
    $id = variable_get('xdruple_commerce_default_warehouse', NULL);
    $site = entity_load_single($entity_type, $id);
  }

  try {
    if (!empty($site) && $site_address = $site->address) {
      $countries = country_get_list();
      $country_match = array_keys($countries, $site_address['country']);
      if (count($country_match) === 1) {
        $country_code = $country_match[0];
      }
      else {
        $country_code = 'US';
      }

      $ship_from_address['thoroughfare'] = $site_address['line1'];
      $ship_from_address['premise'] = $site_address['line2'];
      $ship_from_address['locality'] = $site_address['city'];
      $ship_from_address['administrative_area'] = $site_address['state'];
      $ship_from_address['postal_code'] = $site_address['postalCode'];
      $ship_from_address['country'] = $country_code;
    }
  } catch (\Exception $e) {
    drupal_set_message($e->getMessage(), 'error');
    watchdog('xdruple_commerce', $e->getMessage(), array(), WATCHDOG_ERROR);
  }
}

/**
 * Implements hook_commerce_shipping_service_info_alter().
 */
function xdruple_shipping_commerce_shipping_service_info_alter(&$shipping_services) {
  $allowed_pickup_sites = variable_get('xdruple_shipping_allowed_pickup_sites', array());

  foreach ($shipping_services as $key => $service) {
    if ($service['module'] === 'commerce_pickup') {
      // Extract the xTuple Site Code.
      $service_parts = explode('__', $service['name']);

      if (count($service_parts) === 3) {
        if (isset($allowed_pickup_sites[$service_parts[2]]) && $allowed_pickup_sites[$service_parts[2]] !== 0) {
          // Load the site.
          $site = entity_load_single('xtuple_site', $service_parts[2]);

          // Extract the address.
          $address = xdruple_addr_array_to_addr_info_obj($site->address);

          // Add the address to the description.
          $shipping_services[$key]['description'] .= '<br />' . theme('xdruple_print_address_info', array(
              'printAddressInfoHandler' => new PrintAddressInfoHandler($address, ''),
              'class' => 'xdruple-print-address-info',
            ));
        }
        else {
          // This site is not an allowed pickup site. Unset it from the shipping services.
          unset($shipping_services[$key]);
        }
      }
    }
  }
}

/**
 * Implements hook_rules_condition_info().
 */
function xdruple_shipping_rules_condition_info() {
  $conditions = array();

  $conditions['xdruple_shipping_contains_freight_class_product'] = array(
    'label' => t('Order contains a product with a particular freight class'),
    'parameter' => array(
      'commerce_order' => array(
        'type' => 'commerce_order',
        'label' => t('Order'),
        'description' => t('The order whose line items should be checked for the specified product. If the specified order does not exist, the comparison will act as if it is against a quantity of 0.'),
      ),
      'freightClass' => array(
        'type' => 'list<text>',
        'label' => t('Freight Class'),
        'description' => t('The Freight Class of the product to look for on the order.'),
        'options list' => 'xdruple_fields_get_freight_class_list',
      ),
      'operator' => array(
        'type' => 'text',
        'label' => t('Operator'),
        'description' => t('The operator used with the quantity value below to compare the quantity of the specified product on the order.'),
        'default value' => '>=',
        'options list' => 'commerce_numeric_comparison_operator_options_list',
        'restriction' => 'input',
      ),
      'value' => array(
        'type' => 'text',
        'label' => t('Quantity'),
        'default value' => '1',
        'description' => t('The value to compare against the quantity of the specified product on the order.'),
      ),
    ),
    'group' => t('Commerce Order'),
    'callbacks' => array(
      'execute' => 'xdruple_shipping_rules_contains_freight_class',
    ),
  );

  return $conditions;
}

/**
 * Condition callback: checks to see if one or more particular Freight Classes
 * exist for any products on an order in the specified quantity.
 */
function xdruple_shipping_rules_contains_freight_class($order, $freight_classes, $operator, $value) {
  $quantity = 0;

  // If we actually received a valid order...
  if (!empty($order)) {
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

    // Look for product line items on the order whose products match the
    // specified Freight Classes and increment the quantity count accordingly.
    foreach ($order_wrapper->commerce_line_items as $line_item_wrapper) {
      if (in_array($line_item_wrapper->type->value(), commerce_product_line_item_types())) {
        // Extract the Freight Class from the line item.
        $line_item_freight_class = $line_item_wrapper->commerce_product->freightClass->value();

        // If the line item Freight Class matches, update the total quantity.
        if (in_array($line_item_freight_class, $freight_classes)) {
          $quantity += $line_item_wrapper->quantity->value();
        }
      }
    }
  }

  // Make a quantity comparison based on the operator.
  switch ($operator) {
    case '<':
      return $quantity < $value;
    case '<=':
      return $quantity <= $value;
    case '=':
      return $quantity == $value;
    case '>=':
      return $quantity >= $value;
    case '>':
      return $quantity > $value;
  }

  return FALSE;
}

